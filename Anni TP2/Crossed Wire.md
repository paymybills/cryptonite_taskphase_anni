# Crossed Wire
We were given a ciphertext encrypted using multiple layers, each with a friend's public key. The task was to decrypt the message and retrieve the flag.

**Steps Taken:**

1. **Factorization of N**:  
   I was provided with the prime factors `p` and `q` of `N`. Using these, I calculated `ϕ(N)` as `(p - 1) * (q - 1)`.

2. **Calculating the Private Keys**:  
   With `ϕ(N)` in hand, I had to compute the private key `d` for each friend's public key `(N, e)`. To do this, I used the formula `d = e⁻¹ mod ϕ(N)`. The inverse of `e` modulo `ϕ(N)` gave me the corresponding `d` values.

3. **Decryption Process**:  
   Since the encryption layers were applied in reverse order, I applied each private key in reverse order as well. For each friend's public key, I updated the ciphertext using the formula `c = c^d mod N`. After applying all the private keys, I ended up with the original ciphertext.

4. **Final Step**:  
   Once all the layers were decrypted, I used `number.long_to_bytes(c)` to convert the final ciphertext into readable text. This revealed the flag.

```python
from Crypto.Util import number

# Since encryption was use friends' key, e and d are useless
N, _ = (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097)

# factorization of N
p = 134460556242811604004061671529264401215233974442536870999694816691450423689575549530215841622090861571494882591368883283016107051686642467260643894947947473532769025695530343815260424314855023688439603651834585971233941772580950216838838690315383700689885536546289584980534945897919914730948196240662991266027
q = 161469718942256895682124261315253003309512855995894840701317251772156087404025170146631429756064534716206164807382734456438092732743677793224010769460318383691408352089793973150914149255603969984103815563896440419666191368964699279209687091969164697704779792586727943470780308857107052647197945528236341228473

phi = (q-1)*(p-1)

# reverse encryption process
for key in friend_keys[::-1]:
    d = number.inverse(key[1], phi)
    c = pow(c, d, N)
print(number.long_to_bytes(c))
```

**Flag**: `crypto{3ncrypt_y0ur_s3cr3t_w1th_y0ur_fr1end5_publ1c_k3y}`

---
