# Modular Exponentiation

Not really that tough, given we have python 
```python
# Performing modular exponentiation using the built-in pow function
base = 101
exponent = 17
modulus = 22663

result = pow(base, exponent, modulus)
result  # Result: 19906
```

---

# Public Key

Again, make vairables, make formulae
```python
# Given values for RSA encryption
message = 12
e = 65537
p = 17
q = 23
N = p * q  # Modulus N = p * q

# Performing modular exponentiation for encryption: ciphertext = message^e mod N
ciphertext = pow(message, e, N)
ciphertext  # Result: 301
```

The ciphertext obtained by encrypting the number `12` using `e = 65537`, `p = 17`, and `q = 23` is `301`.

---

# Euler's Totient

```python
# Given values for primes p and q
p = 857504083339712752489993810777
q = 1029224947942998075080348647219

# Euler's totient function Ï•(N) = (p - 1) * (q - 1)
phi_N = (p - 1) * (q - 1)
print(phi_N)
```

Result:

```
882564595536224140639625987657529300394956519977044270821168
```

---

# Private Keys

To calculate the private key \( d \), we need to compute the modular multiplicative inverse of \( e \) modulo \( \phi(N) \), where:

- \( p = 857504083339712752489993810777 \)
- \( q = 1029224947942998075080348647219 \)
- \( e = 65537 \)
- \( \phi(N) = (p - 1) \times (q - 1) \)

Once we have \( \phi(N) \), we can calculate \( d \) using the formula:

\[
d = e^{-1} \mod \phi(N)
\]

This can be done using the Extended Euclidean Algorithm or Python's built-in function `pow(e, -1, \phi(N))` to find the modular inverse. You can try this out using the formula.

```python
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
e = 65537
phi_N = (p - 1) * (q - 1)
d = pow(e, -1, phi_N)
print(d)
```

Result:

```
121832886702415731577073962957377780195510499965398469843281
```

In syllabus for course on Elementary Number Theory, lmao.

---

# RSA Decryption

To decrypt the ciphertext \( c = 77578995801157823671636298847186723593814843845525223303932 \) using RSA, we need to use the private key \( d \) and modulus \( N \). The decryption formula in RSA is:

\[
m = c^d \mod N
\]

```python
c = 77578995801157823671636298847186723593814843845525223303932
N = 882564595536224140639625987659416029426239230804614613279163
d = 121832886702415731577073962957377780195510499965398469843281

m = pow(c, d, N)
print(m)  # Result: 13371337
```

Result:

```
13371337
```

Leetspeak??

---

# RSA Signature: Stepped it up real quick

But it's fairly easy since we can use Python for all this. First, we'll calculate the SHA256 hash of the message, then convert the hash to a number for RSA.

Now we'll use the private key \( d \) to sign the hash (located in `private.key`, saved as `keynotefile`, but you can open it in Notepad) and use the formula:

\[
S = H(m)^d \mod N1
\]

```bash
pip install pycryptodome
```

All Gucci.

Moving on:

```python
from Crypto.Hash import SHA256
from Crypto.Util.number import bytes_to_long

# Given values
message = "crypto{Immut4ble_m3ssag1ng}"
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689
N1 = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803

# Step 1: Hash the message using SHA256
hash_object = SHA256.new(data=message.encode())
message_hash = hash_object.digest()

# Step 2: Convert the hash to a number
hash_number = bytes_to_long(message_hash)

# Step 3: Sign the hash using the private key and the modulus N1
signature = pow(hash_number, d, N1)

# Output the signature
print(signature)
```

Result:

```
13480738404590090803339831649238454376183189744970683129909766078877706583282422686710545217275797376709672358894231550335007974983458408620258478729775647818876610072903021235573923300070103666940534047644900475773318682585772698155617451477448441198150710420818995347235921111812068656782998168064960965451719491072569057636701190429760047193261886092862024118487826452766513533860734724124228305158914225250488399673645732882077575252662461860972889771112594906884441454355959482925283992539925713424132009768721389828848907099772040836383856524605008942907083490383109757406940540866978237471686296661685839083475
```

Too ez.
```
